<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[油脂青年]]></title>
  <link href="https://penghuicai.github.io/atom.xml" rel="self"/>
  <link href="https://penghuicai.github.io/"/>
  <updated>2022-06-23T10:35:16+08:00</updated>
  <id>https://penghuicai.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Redis 发布与订阅之查看订阅信息]]></title>
    <link href="https://penghuicai.github.io/16558847104015.html"/>
    <updated>2022-06-22T15:58:30+08:00</updated>
    <id>https://penghuicai.github.io/16558847104015.html</id>
    <content type="html"><![CDATA[
<p><em>本文仅做为知识分享能力提升，分享不同业务需求场景应对的方式</em>。</p>

<p><code>PUBSUB</code>命令是<code>Redis 2.8</code>新增加的命令之一，客户端可以通过这个命令来<code>查看频道</code>或者<code>模式</code>的相关信息<br/>
比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者</p>

<ul>
<li>
<a href="#toc_0">获取当前被订阅的频道</a>
</li>
<li>
<a href="#toc_1">获取指定频道的订阅者数量</a>
</li>
<li>
<a href="#toc_2">频道发布者(pub)发布消息</a>
</li>
<li>
<a href="#toc_3">频道订阅者(sub)订阅消息</a>
</li>
</ul>


<h1 id="toc_0">获取当前被订阅的频道</h1>

<ul>
<li>命令：</li>
</ul>

<pre class="line-numbers"><code class="language-text">PUBSUB CHANNELS [pattern]
</code></pre>

<ul>
<li>功能：活跃频道组成的列表，用于返回服务器当前被订阅的频道</li>
<li>参数<code>pattern</code>可选：
<ul>
<li>不给定<code>pattern</code>参数，命令返回当前被订阅的<code>所有频道</code></li>
<li>给定<code>pattern</code>参数，命令返回当前被订阅的频道中 与pattern模式<code>相匹配的频道</code></li>
</ul></li>
</ul>

<pre class="line-numbers"><code class="language-text">redis:0&gt;PUBSUB CHANNELS
 1)  &quot;notify:basestore:channel&quot;
 2)  &quot;notify:warehouse:channel&quot;
 3)  &quot;notify:city:channel&quot;
</code></pre>

<h1 id="toc_1">获取指定频道的订阅者数量</h1>

<ul>
<li>命令：</li>
</ul>

<pre class="line-numbers"><code class="language-text">PUBSUB NUMSUB [channel...]
</code></pre>

<ul>
<li>功能：返回指定频道的订阅者数量，返回接收到的信息</li>
<li>参数：<code>channel</code> 必填</li>
</ul>

<pre class="line-numbers"><code class="language-text">redis:0&gt;PUBSUB NUMSUB notify:basestore:channel notify:city:channel
 1)  &quot;notify:basestore:channel&quot;
 2)  &quot;4&quot;
 3)  &quot;notify:city:channel&quot;
 4)  &quot;2&quot;
</code></pre>

<h1 id="toc_2">频道发布者(pub)发布消息</h1>

<ul>
<li>命令：</li>
</ul>

<pre class="line-numbers"><code class="language-text">PUBLISH [channel] [message]
</code></pre>

<ul>
<li>功能：返回<code>接收到消息</code>的<code>订阅者数量</code></li>
<li>参数：<code>channel</code>与<code>message</code>必填</li>
<li>代码示例：</li>
</ul>

<pre class="line-numbers"><code class="language-text">PUBLISH notify:test:channel hello
</code></pre>

<h1 id="toc_3">频道订阅者(sub)订阅消息</h1>

<ul>
<li>命令：</li>
</ul>

<pre class="line-numbers"><code class="language-text">SUBSCRIBE channel [channel ...]
</code></pre>

<ul>
<li>功能：订阅指定的一个或多个频道的信息</li>
<li>参数：<code>channel</code>必填</li>
<li>代码示例：</li>
</ul>

<pre class="line-numbers"><code class="language-text">SUBSCRIBE notify:test:channel
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ZOC Terminal 8.01.5 序列号版 最好用的终端仿真器]]></title>
    <link href="https://penghuicai.github.io/16304764801806.html"/>
    <updated>2021-09-01T14:08:00+08:00</updated>
    <id>https://penghuicai.github.io/16304764801806.html</id>
    <content type="html"><![CDATA[
<p>版本：8.01.5</p>

<p>下载链接：<a href="https://url94.ctfile.com/f/11804594-511085294-5dbf31">ZOC_Terminal_8.01.5.dmg</a><br/>
访问密码：7051</p>

<pre class="line-numbers"><code class="language-text"># the first sn-part:
51698/01027/34713

and the second sn part being:
00937
</code></pre>

<blockquote>
<p>资源来源 <a href="https://xclient.info/s/zoc-terminal.html#versions">Xclient</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cisco AnyConnect Secure Mobility Client v4.8 for Mac 思科]]></title>
    <link href="https://penghuicai.github.io/16304749732861.html"/>
    <updated>2021-09-01T13:42:53+08:00</updated>
    <id>https://penghuicai.github.io/16304749732861.html</id>
    <content type="html"><![CDATA[
<p>版本：4.8.00175</p>

<p>下载链接： <a href="https://url94.ctfile.com/f/11804594-511079987-1e70c0">anyconnect-macos-4.8.00175-predeploy-k9.dmg</a><br/>
访问密码：7051</p>

<blockquote>
<p>资料来源 <a href="https://software.cisco.com/download/home/286281283/type">https://software.cisco.com/</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 工具网站记录]]></title>
    <link href="https://penghuicai.github.io/16304746256161.html"/>
    <updated>2021-09-01T13:37:05+08:00</updated>
    <id>https://penghuicai.github.io/16304746256161.html</id>
    <content type="html"><![CDATA[
<ol>
<li><a href="https://xclient.info/s/">Xclient</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[删库跑路？如果能够快速删除一张亿级表？]]></title>
    <link href="https://penghuicai.github.io/16298733466823.html"/>
    <updated>2021-08-25T14:35:46+08:00</updated>
    <id>https://penghuicai.github.io/16298733466823.html</id>
    <content type="html"><![CDATA[
<p><em>本文仅做为知识分享能力提升，分享不同业务需求场景应对的方式</em>。<br/>
<strong>恶意删库跑路属于删除计算机信息系统中存储的数据，如造成特别严重的后果，行为会构成破坏计算机信息系统罪。</strong></p>

<ul>
<li>
<a href="#toc_0">一、DELETE TABLE</a>
<ul>
<li>
<a href="#toc_1">DELETE 说明</a>
</li>
<li>
<a href="#toc_2">DELETE 示例</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">二、TRUNCATE TABLE</a>
<ul>
<li>
<a href="#toc_4">TRUNCATE 说明</a>
</li>
<li>
<a href="#toc_5">TRUNCATE 示例</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">三、DROP TABLE</a>
<ul>
<li>
<a href="#toc_7">DROP 说明</a>
</li>
<li>
<a href="#toc_8">DROP 示例</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">四、扩展点</a>
<ul>
<li>
<a href="#toc_10">OPTIMIZE TABLE 命令优化表</a>
</li>
</ul>
</li>
</ul>


<h1 id="toc_0">一、DELETE TABLE</h1>

<h2 id="toc_1">DELETE 说明</h2>

<ul>
<li><strong>删除速度慢：</strong>操作会被放在 rollback segment 中，事物提交后才生效，如果有相应的 trigger 执行将被触发，如果删除大数据量的表速度会很慢；</li>
<li><strong>可 rollback 操作：</strong>为 <code>DML</code> 数据操作语言，对数据库中记录做删除标记，每次从表中删除一行，并且同时讲该行的删除操作作为事物记录在日志中保存可以进行 rollback 操作；</li>
<li><strong>不直接释放磁盘空间：</strong>删除表中的逻辑数据，但是物理数据不清除，如主键值、索引等不被清除；虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以重用这部分空间(重用 -&gt; 覆盖)。也可以使用OPTIMIZE TABLE 对碎片进行整理可降低空间占用；</li>
<li><strong>约束影响范围：</strong>删除范围可以添加 <code>WHERE</code> 约束影响范围。 </li>
</ul>

<h2 id="toc_2">DELETE 示例</h2>

<p>删除整张表的数据：</p>

<pre class="line-numbers"><code class="language-mysql">DELETE FROM table_name;
</code></pre>

<p>删除部分数据，添加 where 子句：</p>

<pre class="line-numbers"><code class="language-mysql">DELETE FROM table_name WHERE ... ;
</code></pre>

<p>分批删除数据，避免长事务，减少其他客户端资源等待的时间：</p>

<pre class="line-numbers"><code class="language-mysql">DELETE FROM table_name ORDER BY index_field LIMIT 1000；
</code></pre>

<h1 id="toc_3">二、TRUNCATE TABLE</h1>

<h2 id="toc_4">TRUNCATE 说明</h2>

<ul>
<li><strong>速度快：</strong>通过释放数据表数据所用的数据页，来删除数据，并且只在事务日志中记录页的释放，使用系统和事物日志资源少；</li>
<li><strong>不能 rollback 操作：</strong>为 <code>DDL</code>  数据库模式定义语言，删除数据表所有行，操作立即生效，原数据不放到 rollback segment 中不可进行 rollback 操作。FOREIGN KEY 约束引用的表，不能使它，它不记录在日志所以 trigger 不能被激活；</li>
<li><strong>立刻释放磁盘空间：</strong>同时针对具有自动递增值的字段，做计数重置归零重新计算；</li>
<li><strong>无法控制影响范围：</strong>删除数据表内所有行，但表结构及其列、约束、索引结构等保持不变。</li>
</ul>

<h2 id="toc_5">TRUNCATE 示例</h2>

<p>删除整张表的数据：</p>

<pre class="line-numbers"><code class="language-mysql">TRUNCATE TABLE table_name
</code></pre>

<h1 id="toc_6">三、DROP TABLE</h1>

<h2 id="toc_7">DROP 说明</h2>

<ul>
<li><strong>速度快</strong></li>
<li><strong>不能 rollback 操作：</strong> 为 <code>DDL</code>  数据库模式定义语言，表数据和结构都会被删除；</li>
<li><strong>立刻释放磁盘空间：</strong>删除表定义及该表的所有数据、索引、触发器、约束和权限规范；</li>
<li><strong>无法控制影响范围：</strong>删除数据表内所有行。</li>
</ul>

<h2 id="toc_8">DROP 示例</h2>

<pre class="line-numbers"><code class="language-mysql">DROP TABLE table_name;
</code></pre>

<h1 id="toc_9">四、扩展点</h1>

<h2 id="toc_10">OPTIMIZE TABLE 命令优化表</h2>

<ul>
<li>该命令会重新利用未使用的空间，并整理数据文件的碎片</li>
<li>该命令将会整理表数据和相关的索引数据的物理存储空间，用来减少占用的磁盘空间，并提高访问表时候的IO性能；</li>
<li>不可以频繁操作，释放磁盘空间，优化表期间会锁定表，所以要在空闲时段执行。</li>
<li><code>OPTIMIZE TABLE table_name；</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP HTTPS SSL TLS 相关知识]]></title>
    <link href="https://penghuicai.github.io/16297846641794.html"/>
    <updated>2021-08-24T13:57:44+08:00</updated>
    <id>https://penghuicai.github.io/16297846641794.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">HTTP 相关</a>
<ul>
<li>
<a href="#toc_1">一、HTTP 是什么？</a>
</li>
<li>
<a href="#toc_2">二、HTTP 请求有哪些方法？</a>
</li>
<li>
<a href="#toc_3">三、GET、POST 请求有哪些区别？</a>
</li>
<li>
<a href="#toc_4">四、 GET 请求有 Request body？参数可以像 POST 请求一样放在这里吗？</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">HTTP 相关</h2>

<h3 id="toc_1">一、HTTP 是什么？</h3>

<ul>
<li>HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于万维网（WWW : World Wide Web、3W、Web）服务器传输超文本到本地浏览器的传输协议。</li>
<li>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML文件，图片文件，查询结构等）</li>
<li>HTTP 是一个数据应用层的面向对象协议，由于简洁快速的方式，适用于分布式超媒体信息系统。它与1990年提出，经历几年的使用与发展，得到了不断地完善和扩展。</li>
<li>HTTP协议工作与客户端和服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端（WEB服务端）发送所有请求。Web服务器根据收到的请求，向客户端发送响应信息</li>
</ul>

<h3 id="toc_2">二、HTTP 请求有哪些方法？</h3>

<p>在 <code>HTTP/1.1</code> 共定义了 <code>八种</code> 请求方法（也叫动作）来表明 Request-URL 指定的资源有不同的操作方式</p>

<ul>
<li>HTTP/0.9 定义 <code>一种</code> 请求方法：GET</li>
<li>HTTP/1.0 新增加 <code>两种</code> 请求方法 ：POST 和 HEAD 方法</li>
<li>HTTP/1.1 中，新增加 <code>五种</code> 请求方法：OPTIONS、PUT、DELETE、TRACE 和 CONNECT。</li>
<li>我们一般常用的就是：GET、POST</li>
<li>补充：</li>
</ul>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>GET</td>
<td>向特定的资源发出请求，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于GET，返回的响应实体没有具体的内容，用于获取响应消息头中的元数据</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（列如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>PUT</td>
<td>向指定资源位置上传其最新内容</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务的功能性</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除Request-URL所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">三、GET、POST 请求有哪些区别？</h3>

<ol>
<li>GET 请求在 URL 中传递的参数是有长度限制的，而 POST 没有；</li>
<li>GET 比 POST 更不安全，因为参数直接暴露在URL中，不能传递敏感信息。而 POST 数据不会显示在 URL 中。是放在Request body中；</li>
<li>对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制；</li>
<li>GET 请求参数会被完整保留在浏览器历史记录里。POST 请求参数不会被浏览器保留；</li>
<li>GET 请求只能进行URL编码（application/x-www-from-urlencoded），而 POST 支持多种编码格式；</li>
<li>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置；</li>
<li>GET 在浏览器回退是无害的，而 POST 会再次提交请求。</li>
</ol>

<h3 id="toc_4">四、 GET 请求有 Request body？参数可以像 POST 请求一样放在这里吗？</h3>

<p>其实，前面我们说到 HTTP 是一个基于 TCP/IP，GET 和 POST 在本质上没有区别，都是 HTTP 发送请求的两种请求方法。所以 GET 和 POST 的底层也是TCP/IP。也就是说，GET 和 POST 都是 TCP 连接。所以 GET 加 Request body 或者 POST 的 URL 带上参数，从技术上是完全行的通的。<br/>
TCP 就像汽车，我们用 TCP 运输数据很可靠，从来不会发生丢件少件的现象。<br/>
但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能就被前面载满货物的汽车堵在路上，真个交通系统一定会瘫痪。<br/>
为了避免这种情况发生，交通规则HTTP诞生了，HTTP给汽车运输设定了几个服务类别，包括 GET、POST、PUT 等等。<br/>
HTTP 规定，当执行 GET 请求的时候，要给车贴上 GET 标签，要求其数据货物放在车顶（URL中）以方便记录。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 索引使用情况统计 information_schema.INDEX_STATISTICS]]></title>
    <link href="https://penghuicai.github.io/16140620588310.html"/>
    <updated>2021-02-23T14:34:18+08:00</updated>
    <id>https://penghuicai.github.io/16140620588310.html</id>
    <content type="html"><![CDATA[
<p>MySQL的开源版本 MariaDB、Percona MySQL Server 和 AliSQL 5.6 版本支持统计索引的信息，即可以统计出使用某个索引扫描的行数。依照此，可以找出未被使用的，或者使用频率较低的索引，从而进行下线。</p>

<h2 id="toc_0">示例</h2>

<pre class="line-numbers"><code class="language-text">mysql&gt; select * from wstest.test2 where name=&#39;aaax&#39;;  
+----+------+--------+------+-------+  
| id | name | status | addr | addr2 |  
+----+------+--------+------+-------+  
|  5 | aaax |      5 |      |     0 |  
+----+------+--------+------+-------+  
1 row in set (0.00 sec)  
</code></pre>

<h2 id="toc_1">查看统计信息</h2>

<p>注意：最开始查询 information_schema.INDEX_STATISTICS 表发现结果为空时需要打开参数才会进行统计。<br/>
打开参数：<code>loose_rds_indexstat=1</code></p>

<pre class="line-numbers"><code class="language-text">mysql&gt; select * from information_schema.INDEX_STATISTICS where table_schema=&#39;wstest&#39; and table_name=&#39;test2&#39;;  
+--------------+------------+------------+-----------+  
| TABLE_SCHEMA | TABLE_NAME | INDEX_NAME | ROWS_READ |  
+--------------+------------+------------+-----------+  
| wstest       | test2      | idx_name   |         1 |  
| wstest       | test2      | PRIMARY    |   6314081 |  
+--------------+------------+------------+-----------+  
2 rows in set (0.02 sec)  
</code></pre>

<h2 id="toc_2">统计介绍</h2>

<p>由于在使用 idx_name查 询数据时，扫描行数为1所以在 information_schema.INDEX_STATISTICS 表的 ROWS_READ 字段对应的值为 1 ；<br/>
若再次使用 idx_name 查询，则 ROWS_READ 会再次加 1 。</p>

<h2 id="toc_3">索引下线</h2>

<h3 id="toc_4">设置索引不可见</h3>

<p>使索引不可见，避免突然下线导致某些应用出现慢查。</p>

<pre class="line-numbers"><code class="language-text">mysql&gt; alter table test2 alter index idx_name invisible;
</code></pre>

<h3 id="toc_5">删除索引</h3>

<p>设置索引不可见之后，可以过一段时间，选择低峰期将索引进行删除：</p>

<pre class="line-numbers"><code class="language-text">mysql &gt; alter table test2 drop index idx_name;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vuejs 脚手架 vue-cli 开始 Vuejs 项目]]></title>
    <link href="https://penghuicai.github.io/16068990354499.html"/>
    <updated>2020-12-02T16:50:35+08:00</updated>
    <id>https://penghuicai.github.io/16068990354499.html</id>
    <content type="html"><![CDATA[
<pre class="line-numbers"><code class="language-shell">$ sudo npm install -g vue-cli

❯ Yes, use Yarn  

$ vue list 

$ vue init webpack wlt-demo
# ? Project name wlt-demo
# ? Project description A Vue.js project
# ? Author kellen_cai@126.com
# ? Vue build standalone
# ? Install vue-router? Yes
# ? Use ESLint to lint your code? Yes
# ? Pick an ESLint preset Standard
# ? Set up unit tests No
# ? Setup e2e tests with Nightwatch? No
# ? Should we run `npm install` for you after the # project has been created? (recommended) yarn 

$ cd wlt-demo
# $ npm run dev
$ yarn run dev
# http://localhost:8080
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 允许任何来源 App 运行]]></title>
    <link href="https://penghuicai.github.io/16052597148068.html"/>
    <updated>2020-11-13T17:28:34+08:00</updated>
    <id>https://penghuicai.github.io/16052597148068.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">打开终端应用 执行下方命令，并按提示输入密码即可显示</h2>

<pre class="line-numbers"><code class="language-text"> sudo spctl --master-disable
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP POST 请求被浏览器强制转换为 GET 请求]]></title>
    <link href="https://penghuicai.github.io/16045635590464.html"/>
    <updated>2020-11-05T16:05:59+08:00</updated>
    <id>https://penghuicai.github.io/16045635590464.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">遇到这种情况，检查一下访问的 URL 是 HTTP 还是 HTTPS</h2>

<h2 id="toc_1">原因 Nginx 做 HTTP 重定向到 HTTPS ，POST 才变成 GET 请求</h2>

<ol>
<li>浏览器客户端发送 POST 请求，Nginx 返回 302 暂时性转移到 HTTPS</li>
<li>浏览器客户端收到 302 后，通过 HTTPS 向服务器发起新的请求</li>
<li>新的请求就变成了 GET 请求</li>
</ol>

<h2 id="toc_2">说明</h2>

<p>因为做了Nginx HTTP 重定向到 HTTPS，他们这种访问 API 的方式才出错的。<br/>
大多数 HTTP 浏览器客户端会将引起 302 的 POST 请求转化为 GET 请求发出去。<br/>
其实这是将 302 当做 303 来处理，至于为什么会将 302 当做 303 来处理，据说这是很多老服务器的期望行为，所以一切都是为了兼容性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ImpEx 多表单行导出]]></title>
    <link href="https://penghuicai.github.io/16045412531522.html"/>
    <updated>2020-11-05T09:54:13+08:00</updated>
    <id>https://penghuicai.github.io/16045412531522.html</id>
    <content type="html"><![CDATA[
<pre class="line-numbers"><code class="language-text">&quot;$query=select {pk} from {Consignment} where {code}=&#39;XS20062200002001&#39;&quot;
&quot;#% impex.setTargetFile(&quot;&quot;consignment.txt&quot;&quot;);&quot;
INSERT_UPDATE Consignment;code;consignmentExtend(orderApproveTimes)[alias=&#39;ConsignmentExtend.orderApproveTimes&#39;];consignmentExtend(isNoticeNewPosStatus(code))[alias=&#39;通知新POS状态&#39;];
&quot;#% impex.exportItemsFlexibleSearch(&quot;&quot;$query&quot;&quot;, Collections.EMPTY_MAP, Collections.singletonList( Item.class ), true, true, -1, -1);&quot;
</code></pre>

<p>ImpEx 导出 省市区</p>

<pre class="line-numbers"><code class="language-text">&quot;$query=select {pk} from {District}&quot;
&quot;#% impex.setTargetFile(&quot;&quot;District.txt&quot;&quot;);&quot;
INSERT_UPDATE District;code[alias=&#39;区县&#39;];name[lang=zh,alias=&#39;区县&#39;];city(code);city(name[lang=zh])[alias=&#39;市&#39;];city(region(isocode))[alias=&#39;省&#39;];city(region(name[lang=zh]))[alias=&#39;省&#39;];city(region(country(isocode)))[alias=&#39;国家&#39;];city(region(country(name[lang=zh])))[alias=&#39;国家&#39;];
&quot;#% impex.exportItemsFlexibleSearch(&quot;&quot;$query&quot;&quot;, Collections.EMPTY_MAP, Collections.singletonList( Item.class ), true, true, -1, -1);&quot;
</code></pre>

<p>导出</p>

<pre class="line-numbers"><code class="language-text">&quot;$query=select {c.pk} from {consignment as c} where {c.modifiedtime} &lt; &#39;2021-04-07 09:40:00&#39; AND {c.acceptedStatus} = 8796118745179 &quot;
&quot;#% impex.setTargetFile(&quot;&quot;consignment.txt&quot;&quot;);&quot;
INSERT_UPDATE Consignment;code;status(name[lang=zh])[alias=&#39;状态&#39;];occupyStatus(name[lang=zh])[alias=&#39;占货状态&#39;];acceptedStatus(name[lang=zh])[alias=&#39;接受状态&#39;];abnormalType(name[lang=zh])[alias=&#39;异常类型&#39;];abnormalStatus(name[lang=zh])[alias=&#39;异常状态&#39;];
&quot;#% impex.exportItemsFlexibleSearch(&quot;&quot;$query&quot;&quot;, Collections.EMPTY_MAP, Collections.singletonList( Item.class ), true, true, -1, -1);&quot;
</code></pre>

<h1 id="toc_0">ImpEx 多表单行导入</h1>

<pre class="line-numbers"><code class="language-text">INSERT_UPDATE Consignment;code[unique=true];approvedTimes;consignmentExtend(orderApproveTimes);consignmentExtend(isNoticeNewPosStatus(code));
;XS20062200002001;1;2;PENDING


INSERT_UPDATE Consignment;code[unique=true];approvedTimes;consignmentExtend(orderApproveTimes);
;XS20062200002001;1;2;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HYBRIS HMC 查询慢问题解决]]></title>
    <link href="https://penghuicai.github.io/16025586739645.html"/>
    <updated>2020-10-13T11:11:13+08:00</updated>
    <id>https://penghuicai.github.io/16025586739645.html</id>
    <content type="html"><![CDATA[
<p>hmc 字段加了索引，查询依旧很慢</p>

<h2 id="toc_0">快速解决</h2>

<pre class="line-numbers"><code class="language-text"># local.properties 
# 配置文件 新增字符串属性搜索不区分大小写配置为false
hmc.caseinsensitivestringsearch=false
</code></pre>

<h2 id="toc_1">原因</h2>

<p>当 <code>hmc.caseinsensitivestringsearch=true</code> 时，当拼接 SQL 语句里会自动拼接上忽略大小写的语法，非常影响查询效率。</p>

<h2 id="toc_2">补充说明</h2>

<ul>
<li>Mysql 默认的字符检索策略
<ul>
<li><code>utf8_general_ci</code> 表示不区分大小写，a 和 A 会在字符判断中会被当做一样的</li>
<li><code>utf8_general_cs</code> 表示区分大小写</li>
<li><code>utf8_bin</code> 表示二进制比较，同样也区分大小写</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阿里云 云中谁寄锦书来 免费领取Git命令超大鼠标垫]]></title>
    <link href="https://penghuicai.github.io/15983233728441.html"/>
    <updated>2020-08-25T10:42:52+08:00</updated>
    <id>https://penghuicai.github.io/15983233728441.html</id>
    <content type="html"><![CDATA[
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/8b44a0f0b1ca4d24965809c71ad4463f.jpg" alt="云中谁寄锦书来"/></p>

<h2 id="toc_0">活动地址</h2>

<p><a href="https://developer.aliyun.com/adc/series/devops/">阿里云免费领取Git命令超大鼠标垫活动</a></p>

<h2 id="toc_1">活动时间</h2>

<p>2020.8.19 - 2020.8.28</p>

<h2 id="toc_2">活动奖品说明</h2>

<ol>
<li>目前参与人数少，基本必得奖品</li>
<li>奖品余额每日加200份，共2000份</li>
<li>每天上午10点更新奖品余额</li>
<li>先完成答题但没抢到奖品的用户次10点再来领取</li>
</ol>

<h2 id="toc_3">答题任务</h2>

<ol>
<li>单选选择<code>以上都是</code></li>
<li>多选就是<code>全选</code></li>
</ol>

<h2 id="toc_4">奖品图片</h2>

<p><img src="media/15983233728441/1.jpg" alt="git鼠标垫"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tower Mac 3.5.1 优秀版 Mac上优秀的Git客户端]]></title>
    <link href="https://penghuicai.github.io/15960791395279.html"/>
    <updated>2020-07-30T11:18:59+08:00</updated>
    <id>https://penghuicai.github.io/15960791395279.html</id>
    <content type="html"><![CDATA[
<p>版本：3.5.1</p>

<p>下载链接： <a href="https://url94.ctfile.com/f/11804594-511075606-c21c9e">Tower_3.5.1.dmg</a><br/>
访问密码：7051</p>

<blockquote>
<p>资料来源 <a href="https://www.waitsun.com/tag/tower">麦氪派</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Navicat Premium Mac 15.0.3 优秀版 Mac上最强大的数据库客户端]]></title>
    <link href="https://penghuicai.github.io/15960155953523.html"/>
    <updated>2020-07-29T17:39:55+08:00</updated>
    <id>https://penghuicai.github.io/15960155953523.html</id>
    <content type="html"><![CDATA[
<p>版本：15.0.3</p>

<p>下载链接： <a href="https://url94.ctfile.com/f/11804594-511079911-4f8b34">Navicat_Premium_15.0.3.dmg</a><br/>
访问密码：7051</p>

<blockquote>
<p>资料来源 <a href="https://www.waitsun.com/tag/navicat-premium">麦氪派</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis Desktop Manager 2020.0.79 redis可视化工具 桌面管理工具]]></title>
    <link href="https://penghuicai.github.io/15960109915590.html"/>
    <updated>2020-07-29T16:23:11+08:00</updated>
    <id>https://penghuicai.github.io/15960109915590.html</id>
    <content type="html"><![CDATA[
<p>版本：2020.0.79</p>

<p>下载链接： <a href="https://n459.com/file/11804594-455498807">Redis_Desktop_Manager_2020.0.79.dmg</a></p>

<blockquote>
<p>资源来源 <a href="https://macstore.info/a/Redis-Desktop-Manager-for-mac.html">麦克苹果商店</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ZOC Terminal 7.24.5 序列号版 最好用的终端仿真器]]></title>
    <link href="https://penghuicai.github.io/15960037317603.html"/>
    <updated>2020-07-29T14:22:11+08:00</updated>
    <id>https://penghuicai.github.io/15960037317603.html</id>
    <content type="html"><![CDATA[
<p>版本：7.24.5</p>

<p>下载链接：<a href="https://url94.ctfile.com/f/11804594-511076864-a988b0">ZOC_Terminal_7.24.5.dmg</a><br/>
访问密码：7051</p>

<pre class="line-numbers"><code class="language-text"># the first sn-part:
51698/01027/34713

# and the second sn part being:
00937
</code></pre>

<blockquote>
<p>资源来源 <a href="https://www.waitsun.com/zoc-terminal.html">麦氪派</a><br/>
资源来源 <a href="https://www.waitsun.com/serial/zoc">麦氪派</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正在运行中的脚本进程 npm run build Killed]]></title>
    <link href="https://penghuicai.github.io/15952988486812.html"/>
    <updated>2020-07-21T10:34:08+08:00</updated>
    <id>https://penghuicai.github.io/15952988486812.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">一、错误解释</a>
</li>
<li>
<a href="#toc_1">二、创建交换区原则</a>
<ul>
<li>
<a href="#toc_2">1. 创建的 swap 交换区容量创建原则</a>
</li>
<li>
<a href="#toc_3">2. 内存 IO 请求频繁创建原则</a>
</li>
<li>
<a href="#toc_4">3. 硬盘设备选择创建原则</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">三、创建步骤</a>
<ul>
<li>
<a href="#toc_6">1. 创建 swap 交换区硬盘存储空白文件</a>
</li>
<li>
<a href="#toc_7">2. 格式化文件为 swap 文件系统</a>
</li>
<li>
<a href="#toc_8">3. 启用 swap 文件交换区</a>
</li>
<li>
<a href="#toc_9">4. 设置开机启用</a>
</li>
<li>
<a href="#toc_10">5. 查看 swap 交换区</a>
</li>
<li>
<a href="#toc_11">6. 调整 swap 文件交换区大小或删除</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">一、错误解释</h2>

<blockquote>
<p>运行 npm run build 的时候需要使用很多内存（我们编译需要 8G 左右，系统物理内存只有 4G ），内存不足编译进程就会被系统 kill 。</p>

<p>当服务器的总是内存不足，时常会因为内存不足而引发服务被强制 kill 掉进程的话，在不增加物理内存的情况下，启用 swap 交换区作为虚拟内存是一个不错的选择。</p>
</blockquote>

<h2 id="toc_1">二、创建交换区原则</h2>

<h3 id="toc_2">1. 创建的 swap 交换区容量创建原则</h3>

<blockquote>
<p>交换区大小应该大于实际物理内存的容量大小，但是不要过大，以免造成硬盘空间浪费。通常创建物理内存 <code>2~2.5</code> 倍大小的文件作为交换区。</p>
</blockquote>

<h3 id="toc_3">2. 内存 IO 请求频繁创建原则</h3>

<blockquote>
<p>单一 swap 交换区 IO 队列等待时间过长的话，可以多创建几个 swap 交换区。</p>
</blockquote>

<h3 id="toc_4">3. 硬盘设备选择创建原则</h3>

<blockquote>
<p>优先在 IO 速度最快的硬盘设备上创建。</p>
</blockquote>

<h2 id="toc_5">三、创建步骤</h2>

<h3 id="toc_6">1. 创建 swap 交换区硬盘存储空白文件</h3>

<pre class="line-numbers"><code class="language-text"># $ free -h 
# root 账号 
# 创建一个 8G 的 swap 交换区空白文件
$ dd if=/dev/zero of=/swap bs=1M count=8192
# 运行之后 需要等一会儿 才会成功
</code></pre>

<h3 id="toc_7">2. 格式化文件为 swap 文件系统</h3>

<pre class="line-numbers"><code class="language-text"># root 账号
# -f 使用文件作为 swap 交换区
$ mkswap -f /swap
</code></pre>

<h3 id="toc_8">3. 启用 swap 文件交换区</h3>

<pre class="line-numbers"><code class="language-text">$ swapon /swap
# $ free -h
</code></pre>

<h3 id="toc_9">4. 设置开机启用</h3>

<pre class="line-numbers"><code class="language-text"># 修改/etc/fstab，增加一行
$ vi /etc/fstab
 # i键 进入编辑模式
 # 加入下面这一行
 /swap swap swap defaults 0 0
 # exit键 退出编辑
 # :wq 保存文件并退出vi
</code></pre>

<h3 id="toc_10">5. 查看 swap 交换区</h3>

<pre class="line-numbers"><code class="language-text">$ swapon --show
</code></pre>

<h3 id="toc_11">6. 调整 swap 文件交换区大小或删除</h3>

<pre class="line-numbers"><code class="language-text"># 关闭 swap 
$ swapoff /swap
# $ free -h 
# 删除 swap 文件
$ rm -rf  /swap
# 如需要调整 swap 交换区大小，删除之后 重新创建即可
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打包报错 打包时候UglifyJs压缩的问题]]></title>
    <link href="https://penghuicai.github.io/15935967757482.html"/>
    <updated>2020-07-01T17:46:15+08:00</updated>
    <id>https://penghuicai.github.io/15935967757482.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">报错内容</a>
</li>
<li>
<a href="#toc_1">报错原因</a>
<ul>
<li>
<a href="#toc_2">我遇到的问题1</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">解决办法</a>
<ul>
<li>
<a href="#toc_4">roadhog</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">报错内容</h2>

<pre class="line-numbers"><code class="language-text">Failed to compile. 133.a17a298b.async.js from UglifyJs 
# 问题1
Unexpected token: operator (&gt;) [133.a17a298b.async.js:51671,24] 

# 问题2
from UglifyJs Unexpected token: keyword (const)

# 问题3
from UglifyJs Unexpected token: punc ())
</code></pre>

<h2 id="toc_1">报错原因</h2>

<p>压缩工具 uglify 只支持 es5 的语法。<br/>
当遇到 const、let、()=&gt; 类似的语法将跑出上面异常</p>

<h3 id="toc_2">我遇到的问题1</h3>

<p>@ant-design/charts 依赖的 d3-regression 使用了 es6 语法。<br/>
但是现在使用的 roadhog，压缩工具 uglify-js 不支持 es6 语法， 所以 build 打包报错了</p>

<h2 id="toc_3">解决办法</h2>

<h3 id="toc_4">roadhog</h3>

<pre class="line-numbers"><code class="language-text">#.roadhogrc.js 文件 加入下面内容
export default {
    &quot;extraBabelIncludes:&quot; [
        &quot;node_modules/d3-regression&quot;,
        &quot;node_modules/xxxx&quot;
    ]
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GIT 仓库迁移并保留分支和历史提交]]></title>
    <link href="https://penghuicai.github.io/15905697716646.html"/>
    <updated>2020-05-27T16:56:11+08:00</updated>
    <id>https://penghuicai.github.io/15905697716646.html</id>
    <content type="html"><![CDATA[
<blockquote>
</li>
<li>
<a href="#toc_1">进入本地 clone 的旧库目录</a>
</li>
<li>
<a href="#toc_2">移除旧库的地址替换成新库地址</a>
</li>
<li>
<a href="#toc_3">将新地址镜像 core 直接推到远程新库</a>
</li>
<li>
<a href="#toc_4">删除本地库 core，然后再重新拉取</a>
</li>
<li>
<a href="#toc_5">已搞定</a>
</li>
</ul>


<h2 id="toc_0">clone 旧库的镜像</h2>
</blockquote>

<pre class="line-numbers"><code class="language-text">git clone --mirror https://xxx.com/old/core.git
</code></pre>

<h2 id="toc_1">进入本地 clone 的旧库目录</h2>

<pre class="line-numbers"><code class="language-text">cd core.git
</code></pre>

<h2 id="toc_2">移除旧库的地址替换成新库地址</h2>

<pre class="line-numbers"><code class="language-text">git remote set-url --push origin https://xxx.com/new/core.git
</code></pre>

<h2 id="toc_3">将新地址镜像 core 直接推到远程新库</h2>

<pre class="line-numbers"><code class="language-text">git push --mirror
</code></pre>

<h2 id="toc_4">删除本地库 core，然后再重新拉取</h2>

<pre class="line-numbers"><code class="language-text">rm -rf core.git

git clone -b prod https://xxx.com/new/core.git
</code></pre>

<h2 id="toc_5">已搞定</h2>

<pre class="line-numbers"><code class="language-text">git clone --mirror old.git

cd old.git

git remote set-url --push origin new.git

这一步的时候，可以删除不需要的分支和版本

git push --mirror
</code></pre>

]]></content>
  </entry>
  
</feed>
